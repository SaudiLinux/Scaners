local http = require("socket.http")
local ltn12 = require("ltn12")
local json = require("dkjson")
local socket = require("socket")

-- Main Vulnerability Scanner Class
VulnerabilityScanner = {}
VulnerabilityScanner.__index = VulnerabilityScanner

function VulnerabilityScanner:new(url)
    local self = setmetatable({}, VulnerabilityScanner)
    self.target_url = url
    self.vulnerabilities = {}
    self.scan_results = {}
    self.user_agent = "VulnScanner/1.0"
    self.timeout = 10
    self.redirects = true
    self.max_redirects = 5
    return self
end

-- HTTP Request Function
function VulnerabilityScanner:http_request(url, method, headers, body)
    local response = {}
    local request_body = body or ""
    
    local request_headers = headers or {}
    request_headers["User-Agent"] = self.user_agent
    request_headers["Accept"] = "*/*"
    request_headers["Connection"] = "close"
    
    local response_body = {}
    
    local result, status_code, response_headers = http.request{
        url = url,
        method = method or "GET",
        headers = request_headers,
        source = ltn12.source.string(request_body),
        sink = ltn12.sink.table(response_body)
    }
    
    return {
        status = status_code,
        headers = response_headers or {},
        body = table.concat(response_body),
        result = result
    }
end

-- URL Validation and Parsing
function VulnerabilityScanner:validate_url(url)
    if not url:match("^https?://") then
        url = "http://" .. url
    end
    
    local protocol, host, port, path = url:match("^(https?)://([^:/]+):?(%d*)(/?.*)$")
    
    if not protocol or not host then
        return nil, "Invalid URL format"
    end
    
    port = port ~= "" and port or (protocol == "https" and "443" or "80")
    path = path ~= "" and path or "/"
    
    return {
        protocol = protocol,
        host = host,
        port = port,
        path = path,
        full_url = protocol .. "://" .. host .. ":" .. port .. path
    }
end

-- Vulnerability Structure
function VulnerabilityScanner:create_vulnerability(name, severity, description, exploit_details, remediation)
    return {
        name = name,
        severity = severity, -- critical, high, medium, low, info
        description = description,
        exploit_details = exploit_details,
        remediation = remediation,
        discovered_at = os.date("%Y-%m-%d %H:%M:%S"),
        cve_references = {}
    }
end

-- Add vulnerability to results
function VulnerabilityScanner:add_vulnerability(vuln)
    table.insert(self.vulnerabilities, vuln)
    self:log_vulnerability(vuln)
end

-- Logging function
function VulnerabilityScanner:log_vulnerability(vuln)
    local severity_colors = {
        critical = "\27[31m", -- red
        high = "\27[91m",     -- bright red
        medium = "\27[33m",   -- yellow
        low = "\27[32m",      -- green
        info = "\27[36m"      -- cyan
    }
    
    local reset_color = "\27[0m"
    local color = severity_colors[vuln.severity] or ""
    
    print(string.format("%s[%s] %s - %s%s", 
        color, vuln.severity:upper(), vuln.name, vuln.description, reset_color))
end

-- Main scanning function
function VulnerabilityScanner:scan()
    print("[*] Starting vulnerability scan for: " .. self.target_url)
    print("[*] Validating target URL...")
    
    local url_info, err = self:validate_url(self.target_url)
    if not url_info then
        print("[!] Error: " .. err)
        return false
    end
    
    self.target_url = url_info.full_url
    print("[+] Target validated: " .. self.target_url)
    
    -- Start vulnerability tests
    print("[*] Beginning vulnerability assessment...")
    
    -- Test for common vulnerabilities
    self:test_sql_injection()
    self:test_xss()
    self:test_directory_traversal()
    self:test_file_inclusion()
    self:test_xxe()
    self:test_csrf()
    self:test_insecure_headers()
    self:test_information_disclosure()
    self:test_weak_authentication()
    
    print("\n[*] Scan completed!")
    print(string.format("[*] Found %d vulnerabilities", #self.vulnerabilities))
    
    return true
end

-- Generate detailed report
function VulnerabilityScanner:generate_report()
    local report = {
        scan_info = {
            target = self.target_url,
            scan_date = os.date("%Y-%m-%d %H:%M:%S"),
            total_vulnerabilities = #self.vulnerabilities
        },
        vulnerabilities = self.vulnerabilities,
        summary = self:generate_summary()
    }
    
    return report
end

-- Generate vulnerability summary
function VulnerabilityScanner:generate_summary()
    local summary = {
        critical = 0,
        high = 0,
        medium = 0,
        low = 0,
        info = 0
    }
    
    for _, vuln in ipairs(self.vulnerabilities) do
        summary[vuln.severity] = (summary[vuln.severity] or 0) + 1
    end
    
    return summary
end

-- Save report to file
function VulnerabilityScanner:save_report(filename)
    local report = self:generate_report()
    local json_report = json.encode(report, { indent = true })
    
    local file = io.open(filename, "w")
    if file then
        file:write(json_report)
        file:close()
        print("[+] Report saved to: " .. filename)
        return true
    else
        print("[!] Error: Could not save report to " .. filename)
        return false
    end
end

return VulnerabilityScanner